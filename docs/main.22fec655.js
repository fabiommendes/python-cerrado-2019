parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"ans/":[function(require,module,exports) {

},{}],"epB2":[function(require,module,exports) {
"use strict";var n=require("fs"),e='name: inverse\nlayout: true\nclass: center, middle, inverse\n---\n\n# Programação funcional em Python. Funciona?\n\n## Python Cerrado 2019\n\nFábio Macêdo Mendes\n\n---\n\n## Programação orientada a funções\n\n1936, Alonzo Church, Cálculo lambda\n\n---\n\nlayout: false\n.left-col[\n## Lambda\ncálculo lambda utiliza **apenas** lambdas\n]\n.right-col[\nFunção fatorial, implementanda como cálculo lambda em Python\n\n```python\n(lambda f: lambda x: f(f, x))(\n(lambda f, n: \n  (lambda cond, then, else_: cond(then, else_))(\n    (lambda n: n(lambda _: lambda a, b: b(), \n                 lambda a, b: a()))(n), \n     lambda: lambda f, x: f(x), \n     lambda: (lambda n, m: lambda f, x: \n       n(lambda y: m(f, y), x))(\n         n, \n         f(f, \n           (lambda n: lambda f, x: \n             (lambda k: k(lambda a: a))\n           (n(lambda g: lambda h: h(g(f)), lambda y: x)))\n           (n))))))\n```\n]\n<div class="WAT">WAT??!</div>\n\n---\n.left-col[\n## Python vs. Lambda\n]\n.right-col[\n\n### Python\n\n```python\ndef fat(n):\n    if n == 0:\n        return 1\n    else:\n        return n * fat(n - 1)\n```\nFunciona bem com seres humanos\n\n### Lambda\n```python\n(lambda: lambda f: lambda x: ...)\n```\n1 expressão Python, 208 bytes gzipped, onde acrescentamos:\n- Booleanos e o comando "if"\n- Multiplicação e subtração de números naturais\n- Recursão de funções\n- (além do fatorial)\n]\n\n---\n## Turing, .grey[Hardware] vs. Church, .grey[Software]\n\n.spaced[\n- Máquina de Turing\n    + Assembler <span class="red bold">></span> Gotos <span class="red bold">></span> Programação estruturada (1958, Algol)\n    + O foco mudou para arquitetura e otimizações\n- Cálculo lambda (1958, Lisp)\n    - *"A programação pode se libertar do estilo Von Neumann?"*\n    - Haskell (1990)\n    - Renascimento funcional (2000s) \n- Convergência\n```java\n// Lambdas em Java e C++!\n(s) -> System.out.println("Hello " + s + "!");\n[] (auto s) { cout << "Hello " << s << "!" << endl; }\n```\n]',a="---\nname: inverse\nclass: center, middle, inverse\n\n# Python é funcional?\n\n---\n\n.left-col[\n## Funções são valores\n### Lisp, 1958\n]\n\n.right-col[\n### Definimos uma função,\n\n```python \ndef add(x, y):\n    return x + y\n```\n\n### salvamos em algum lugar qualquer,\n\n```python \noperators = {'+': add, '-': ...}\n```\n\n### e usamos como uma variável, sem cerimônias,\n\n```python \nop = '+'\nprint(operators[op](40, 2))\n```\n]\n---\n\n.left-col[\n## Funções são valores\n### Lisp, 1958\n### São argumentos\n]\n\n.right-col[\n### Criamos uma função\n\n```python\ndef map(func, lst):\n    result = []\n    for x in lst:\n        result.append(func(x))\n    return result\n```\n\n### que recebe outra função como argumento\n\n```python\n>>> map(abs, [-1, 2, -3, 4])\n[1, 2, 3, 4]\n```\n]\n\n---\n\n.left-col[\n## Funções são valores\n### Lisp, 1958\n### São argumentos\n### São resultados\n]\n\n.right-col[\n### Funções podem criar e retornar novas funções,\n\n```python\ndef incr_by(n):\n    def incrementer(x):\n        return x + n\n    return incrementer\n```\n\n### onde compomos\n\n```python\n>>> map(incr_by(2), [10, 20, 30, 40])\n[12, 22, 32, 42]\n```\n\n### e transformamos\n\n```python\ndef flip(f):\n    def flipped(x, y):\n        return f(y, x)\n    return flipped\n```\n]\n\n---\n\n.left-col[\n## Funções são valores\n### Lisp, 1958\n### São argumentos\n### São resultados\n### São lambdas\n]\n\n.right-col[\n### Lambdas definem funções como expressões\n\n```python\nflip2 = lambda f: lambda x, y: f(y, x)\n```\n\n### Internamente são idênticas às funções normais\n\n```python\n>>> type(flip2) == type(flip)\nTrue\n```\n### Lambdas são limitadas a um único comando (porque o Guido quis e é tudo o que precisamos)\n\n```python\n>>> map(lambda x: 2 * x, [1, 2, 3, 4])\n[2, 4, 6, 8]\n```\n]\n",o="---\n\nclass: center, middle, inverse\n\n# Exemplo\n## Lista simplesmente encadeada\n\n---\n.left-col[\n## Lista\n### Imutável\n### Eficiente\n### Simples\n]\n\n.right-col[\n\n### Pares de valores terminados em None\n\n```python\nfrom collections import namedtuple\n\ncons = namedtuple('Cell', ['head', 'tail'])\n```\n\n.linked-list[ ]\n]\n\n---\n\n.left-col[\n## Lista\n### Imutável\n### Eficiente\n### Simples\n### Folds!\n]\n\n.right-col[\n\n### Precisamos conhecer duas funções\n\nAplica `f` em cada par de elementos reduzindo a lista da direita para a esquerda...\n\n```python\ndef foldr(f, start, lst):\n    if lst is None:\n        return start\n    else:\n        return f(lst.head, foldr(f, start, lst.tail))\n```\n\n...ou da esquerda para a direita\n```python\ndef foldl(f, start, lst):\n    while lst is not None:\n        head, lst = lst\n        start = f(head, start)\n    return start\n```\n]\n\n---\n### Composição\n\n.pull-left[\n```python\nadd = lambda x, y: x + y\n\ndef sum(xs):\n    return fold(add, 0, xs)\n```\n]\n\n.pull-right[\n```python\njoin = lambda x, y: f'{x}, {y}'\n\ndef show(xs):\n    return fold(join, '', xs)\n```\n]\n\n.margin-1.center[\n**Note o padrão:** funções usam `fold` fixando os primeiros argumentos\n]\n\n.center[\n<i class=\"fa fa-angle-double-down red\" style=\"font-size: 4rem\"></i>\n]\n\n.pull-left[\n```python\nfrom functools import partial\nfrom operator import add, mul\n\n\nsum = partial(fold, add, 0)\nproduct = partial(fold, mul, 1)\nshow = partial(fold, join, '')\n```\n]\n\n.pull-right[\n```python\nfrom sidekick import curry\n\nfold = curry(3, fold)\n\nsum = fold(add, 0)\nproduct = fold(mul, 1)\nshow = fold(join, '')\n```\n]\n\n.center[\nCriamos novas funções por *especialização*\n]\n\n---\n\n## Biblioteca completa de *one-liners**\n\n```python\n# Tamanho da lista\nlength = fold(lambda _, n: n + 1, 0)\n\n# Concatena duas listas\nconcat = flip(foldr(cons))\n\n# Inverte lista\nreverse = foldl(cons, None)\n\n# Aplica função em cada elemento da lista\nmap = lambda f, xs: foldr(lambda x, y: cons(f(x), y), None, xs)\n\n# Seleciona elementos aceitos pelo predicado\nfilter = lambda pred, xs: foldr(filter_f(pred), None, xs)\n\n# Intercala x nos elementos da lista\nintersperse = lambda x, xs: cons(xs.head, foldr(interspace_f(x), None, xs.tail))\n\n\n# Funções auxiliares\nfilter_f = lambda pred: lambda x, lst: cons(x, lst) if pred(x) else lst\ninterspace_f = lambda sep: lambda x, lst: cons(sep, cons(x, lst))\n```\n\n.right[*às vezes é necessário desenhar para entender...]\n",s='---\n\nclass: center, inverse, powerpuff\n\n# Funções pequenas, mas superpoderosas\n\n---\n\n.left-col[\n## Funções\n### map\n]\n.right-col[\n## Mais .red[map]s e menos .red[for]s\n\nAplica função em cada termo da lista ou sequência\n\n```python\ndouble = lambda x: 2 * x\n\nmap(double, [1, 2, 3, 4]) == [2, 4, 6, 8]\n```\n\nPode ser aplicada a sequências infinitas\n\n```python\nfrom itertools import count\n\nmap(double, count(1)) == [2, 4, 6, ...]\n```\n\nE usada com funções de vários argumentos\n\n```python\nfrom operators import add\n\nmap(add, [1, 2, 3], [4, 5, 6]) == [5, 7, 9]\n```\n]\n\n\n---\n\n.left-col[\n## Funções\n### map\n### filter\n### reduce\n]\n.right-col[\n## Mais .red[filter]s e menos .red[if]s\n\n`filter` preserva apenas os termos aceitos pela função de predicado\n\n```python\nis_large = lambda x: x >= 10\n\nfilter(is_large, [1, 2, 3, 42]) == [42]\n```\n\n`reduce` reduz sequência usando operador\n\n```python\nfrom functools import reduce\n\nreduce(add, [1, 2, 3, 4]) == 1 + 2 + 3 + 4\n```\n]\n\n\n---\n\n.left-col[\n## Composição\n### The Bad\n]\n\n.right-col[\n## Criamos *pipelines* de processamento de dados\n\n**PROBLEMA:** Remover as entradas nulas, converter para número e calcular o valor máximo\n\n```python\ndata = ["R$100.00", None, "R$42.00", "R$40.00", ...]\n\nclean = filter(lambda x: x is not None, data)\nnumbers = map(lambda x: float(x[2:]), clean)\nrichest = reduce(max, numbers)\n```\n\n.pipeline[ ]\n]\n\n\n---\n\n.left-col[\n## Composição\n### The Bad\n### The Good\n]\n\n.right-col[\n## Separando dados do algoritmo\n\nCom auto-currying, o dado fica por último\n\n```python\nimport sidekick as sk\n\nclean_data = sk.filter(lambda x: x is not None)\nto_numbers = sk.map(lambda x: float(x[2:]))\nmaximum = sk.reduce(max)\n\nrichest = maximum(to_numbers(clean_data(data)))\n```\n\nDaí, extraímos o pipeline\n\n```python\nprocess = sk.pipeline(\n    sk.filter(lambda x: x is not None),\n    sk.map(lambda x: float(x[2:])),\n    sk.reduce(max),\n)\n\nrichest = process(data)\n```\n\nTambém podemos usar operadores `f >> g >> h`\n]\n\n\n\n---\n\n.left-col[\n## Composição\n### The Bad\n### The Good\n### The Ugly\n]\n\n.right-col[\n## Imperativo\n\n```python\ndef process(data):               # pipeline\n    res = 0                      # reduce\n    for x in data:               # map/filter/reduce?\n        if x is not None:        # filter\n            y = float(x[2:])     # map\n            res = max(x, y)      # reduce\n    return res                   # reduce\n```    \n\n- Longo e aninhado\n- Mistura considerações intenções\n- Não abstrai fluxos de controle\n- Infelizmente, é o que o Python gosta :(\n]',r='---\n\nclass: center, inverse, middle\n\n# Iteradores e sequências infinitas\n## (Como ser funcional em um mundo em eterna mudança)\n---\n\n.left-col[\n## Iteráveis\n### Criação\n]\n.right-col[\n## Um Iterável produz uma sequência de valores\n\nE uma interface previsível e minimalista\n\n```python\nit = iter([1, 2, 3, 4])\n\nnext(it) == 1\nnext(it) == 2\n...\n```\n\nTambém pode ser criada com funções geradoras\n\n```python\ndef fibos():\n    x, y = 1, 1\n    while True:\n        yield x\n        x, y = y, x + y\n```\n\n(E não temos medo de sequências infinitas...)\n]\n\n---\n\n.left-col[\n## Iteráveis\n### Criação\n### Mutação\n]\n\n.right-col[\n## Modificamos o iterável para revelar informação\n\nVamos calcular a razão áurea como o limite de dois \nnúmeros de Fibonacci\n\n```python\nfrom sidekick import X, Y\n\nratios = (y / x for x, y in window(2, fibos()))\nratios = sk.until_convergence((X == Y), ratios)\n```\n\n- `window(n)`: percorre o iterador em uma janela de n elementos\n- `until_convergence(pred)`: termina iteração quando predicado for verdadeiro\n]\n---\n\n.left-col[\n## Iteráveis\n### Criação\n### Mutação\n### Destruição\n]\n\n.right-col[\n## Finalmente, consumimos o iterável\n\n```python\ngolden_ratio = sk.last(ratios)   # 1.618033988749895\n```\n\n### Importante!\n\n- Iteradores são radicalmente **mutáveis**\n- Uma vez lido, o iterador é consumido para sempre\n- Crie um pipeline, passe o iterador somente uma vez\n- Para persistência, use listas e tuplas\n\n### Funcional pragmático em Python\n\n- **Funções** + **iteradores** + **lazyness**\n- Use imutabilidade e funções puras com moderação\n- <i class="fa fa-heart red" style="transform: scale(1.5); margin: 0 0.5rem;"></i> geradores e *list comprehensions*\n\n]\n\n\n---\n\n.left-col[\n## Iteráveis\n### Criação\n### Mutação\n### Destruição\n### Bônus\n]\n\n.right-col[\n## Crivo de Erastótenes\n\n```python\nfrom sidekick.misc.lazylist import LazyList\nfrom sidekick import N\n\ndef sieve(nums):\n    p, nums = sk.uncons(nums)\n    yield p\n    yield from sieve(n for n in nums if n % p != 0)\n\nprimes = LazyList(sieve(N[2, 3, ...]), size=\'inf\')\nprimes == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...]\n```\n]',t='---\n\nclass: center, inverse, middle\n\n# Criando funções\n## Composição e especialização\n---\n\n.left-col[\n## Funções\n### Especialização\n]\n\n.right-col[\nProgramação funcional depende de mecanismos efetivos para criação e composição de funções\n\n```python\n# Tempo sobrando, vida tranquila...\ndef succ(n: int) -> int:\n    """Return the next integer after n"""\n\n    return n + 1\n\n# Ok, se vc tem pressa\nsucc = lambda n: n + 1\n\n# ou não tem escrúpulos\nsucc = (1).__add__\n\n# Entra o Sidekick\nfrom sidekick import op, fn, X, Y, placeholder as _\n\n# Usando auto-currying\nsucc = op.add(1)\n\n# Fábrica de funções\nsucc = (X + 1)\n\n# Placeholder\nsucc = fn(_ + 1)\n```\n]\n---\n\n.left-col[\n## Funções\n### Especialização\n### Composição\n]\n\n.right-col[\n## Juntamos funções simples para construir outras funções específicas\n\n```python\nsucc = fn(_ + 1)\ndouble = fn(2 * _)\nincr_all = sk.map(succ)\n\nnext_after_double = double >> succ\n```\n\n## Qualquer função pode ganhar estes poderes\n\n```python\n@fn\ndef fat(n):\n    return 1 if n <= 0 else n * fat(n - 1)\n\n@fn.curry(2)\ndef diff_h(h, f):\n    return lambda x: (f(x + h) - f(x)) / h\n\ndiff = diff(1e-6)\n```\n]\n',i="---\n\nclass: center, inverse, middle\n\n# Como ser preguiçoso\n---\n\n# Lazy programming\n\n\n### pro·cras·ti·nar\nDeixar para outro dia ou para depois; adiar, delongar, postergar*.\n\n.lazy-disclaimer[\n*com a esperança de que se enrolar, as coisas se resolverão\n]\n.lazy[]\n\n---\n\n.left-col[\n## Lazyness\n### Processamento de Dados\n]\n\n.right-col[\n## Geradores e operações em iteradores são \"lazy\"\n\n```python\nfrom turtle import fd, lt\nfrom math im    port sqrt\n\nscale = 10  # px\nsk.pipe(\n    fibos(),\n    sk.map(sqrt),\n    sk.map(op.mul(scale)),\n    sk.map(lambda x: fd(x), lt(90)),\n    sk.take(20),\n)\n```    \n\n- Sequências infinitas? Sem problemas\n- Uso de memória eficiente\n- Fácil composição\n- Computa somente o necessário\n]\n\n---\n.left-col[\n## Lazyness\n### Processamento de Dados\n### Valores\n]\n\n.right-col[\n## Thunks\n\n```python\nfrom turtle import fd, lt\nfrom math import sqrt\n\ndef thunk(f):\n    def lazy():\n        nonlocal value\n        try:\n            return value\n        except NameError:\n            value = f(*args, **kwargs)\n            return value\n    return lazy\n# (ou from sidekick import thunk)\n\n@thunk\ndef config():\n    with  open('config.json') as fd:\n        cfg  = json.load(fd)\n    return cfg\n\n# inicializa somente uma vez\npath = config()['path']\nrasa_cfg = config()['plugins']['rasa'] \n...    \n```\n]\n\n---\n.left-col[\n## Lazyness\n### Processamento de Dados\n### Valores\n### Classes\n]\n\n.right-col[\n## Classes também podem ser lazy\n\n```python\nfrom sidekick import alias, delegate_to, lazy\n\nclass Vector:\n    x: float\n    y: float\n\n    size = lazy(lambda self: sqrt(self.x**2 + self.y**2))\n    length = alias('size')\n\n\nclass Arrow:\n    start: Vector\n    step: Vector\n    \n    size = delegate_to('step')\n```    \n]\n\n---\n.left-col[\n## Lazyness\n### Processamento de Dados\n### Valores\n### Classes\n### Zumbis\n]\n\n.right-col[\n## Deferred, Zombies e lazy imports\n\n```python\nfrom sidekick import import_later, zombie, deferred\nfrom django_app.models import User\n\n# Importar módulos pesados \npd = import_later('pandas')\n\n# Carregar objetos com inicialização lenta \n# ou que não podem ser criados no contexto do\n# módulo\nusers = deferred(\n    User.objects\n        .filter(...))\n\n# Objeto assume a classe do proxy após inicialização\nwebmaster = deferred(lambda: \n        User.objects\n            .filter(is_superuser=True)\n            .first())\n```    \n]",l='---\n\nclass: center, inverse, middle\n\n# Considerações finais\n## Funcional ou não?\n\n---\n\nlayout: false\nclass: lambda \n\n## Arquiteturas funcionais\n\n- Funções são Lego e classes Playmobil\n- Compomos funções simples para gerar funções complexas\n- Centrado em dados: T(data) -> new_data\n- Testáveis e reutilizáveis\n\n---\nclass: lambda \n\n## Mas Python não é funcional...\n\n- Sintaxe carregada e imperativa\n- Recursão e abstrações podem ser caras\n- Pouquíssimas garantias estáticas\n- Boas práticas exigem disciplina\n- Estruturas de dados inadequadas \n- Mutabilidade em todo canto\n\n---\nclass: lambda \n\n## Programação funcional para o bem comum! \n\n- Entenda o fluxo de dados e não o diagrama de classes\n- Favoreça pipelines de dados e iterfaces imutáveis\n- Componha funções\n    + função boa é uma função pequena\n    + evite efeitos colaterais\n- Abrace a segunda ordem\n- Python pode não ser ideal, </br>mas é suficiente\n\n---\nclass: lambda \n\n## Referências\n\n- [Why Functional Programming Matters](https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)\n- [Functional Programming with Python](http://kachayev.github.io/talks/uapycon2012/index.html)\n- [Stop writing classes](https://www.youtube.com/watch?v=o9pEzgHorH0)\n- [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/)\n\n\n---\nclass: lambda \n\n## Bibliotecas\n\n- Stdlib\n    + itertools, functools, operator\n- Outros\n    + [toolz](https://toolz.readthedocs.io/en/latest/)\n    + [fn.py](https://github.com/kachayev/fn.py)\n    + [sidekick (beta)](https://pypi.org/project/sidekick/)\n    + [django.utils.functional](https://docs.djangoproject.com/en/2.1/_modules/django/utils/functional/)\n\n\n---\nclass: lambda \n\n## Outras linguagens\n\n- ELM: puramente funcional para Frontend\n- Haskell: funcional séria\n- Scala: funcional + OO\n- Scheme: LISP muito utilizada  \n- Clojure: uma LISP moderna\n\n\n---\n<iframe width="750" height="500" src="https://www.youtube.com/embed/Ci48kqp11F8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen style="margin: 4rem auto"></iframe>\n',d=e+a+o+s+r+t+i+l,m=document.querySelector("#source");m.innerHTML=d;var c=remark.create();
},{"fs":"ans/"}]},{},["epB2"], null)
//# sourceMappingURL=https://fabiommendes.github.io/python-cerrado-2019/main.22fec655.js.map